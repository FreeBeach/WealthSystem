using System.Collections;
using System.Collections.Generic;
using UnityEngine;

#region  位置同步方案

/*
 * 首先信任客户端的数据。客户端发送自己的位置坐标和运动矢量（包含有方向和速度）以及当前时间给服务器。
 * 服务器收到后，认为在某一时刻（客户端时间），这个玩家在什么位置，怎样运动的。
 * 根据对时求得的时差和估算的延迟，可以预计客户端当前时刻（服务器时间）应该是什么状态（位置以及运动矢量）。
 * 把这个信息广播给所有的玩家。

 *每个玩家收到后，再根据他们之前估算出来的时差以及延迟，得到本地时间当时，所有玩家的状态。
 *因为玩家运动是连续的。上面得到的状态和他们看到的这些角色的时间状态会有偏差。校准偏差分两种情况讨论。

 *一种，收到的信息是属于其它玩家的。我们从最新得到的状态信息，预测一段时间之后（比如一秒后的状态），用一条直线运动去修正。
 *即，设想一秒后这个玩家在哪里，然后反推回现在应该用什么速度运动可以在一秒后到达那个地方。
 *另一种，收到的信息是属于自己的，即服务器认可的自己的状态（并广播给别人了）。
 *这个偏差是由于服务器的预测补偿造成的。为了保持用户的操作手感，对于不太极端的偏差，我们全部不修正，
 *而是依然发送客户端自己操作的位置状态给服务器。服务器那边玩家是处于一种离散的运动状态的。
 *而其他人见到你会再做预测补偿；如果和服务器相差过于剧烈，则直接跳转到服务器认可的新位置。

 *这里几乎全部相信客户端的行为，以获取最好的操作手感。防止客户端作弊是另外一个话题，也不是不能解决的，但目前不要碰了。
 */



/* 发送启发思路
 * 每次发送完一个完整的位置信息后，预测服务器看待这个位置信息包一秒后的位置大约在哪里。
 * 每次变化做一个累积，一秒内都但不用立刻发送。但每次小的状态改变都和假设的预测位置做一些比较，
 * 如果位置偏差比较大，就可以提前发送。否则一直累计到一秒再发送
 * 这个一秒的周期可以根据实际测试情况来调整。可能一秒太短，也可能过长了。
 * 
 */
/*接收启发思路
 * 每次收到服务器发送过来的新的玩家位置信息时，都在里面会找到一个时间戳，表识的包发出的服务器时间。
 * 客户端可以验算之前的网络延迟是否正确。如果网络延迟稳定在一个固定值，说明没有问题。
 * 但如果延迟值为负数，则说明之前的对时流程中网络不稳定
 * （可能是因为上下行时间偏差比较大造成的，也可能是当时服务器负载很大，造成了较大的内部延迟），
 * 造成本地时间和服务器时间的时差计算错误。这个时候重新发起对时流程就好了。
 * */

#endregion

/// <summary>
/// 位置同步脚本
/// </summary>
public class NetSynTransform : MonoBehaviour
{
    //逻辑时长的步长单位长度，毫秒
    const float timeStepMSEC=10;
    //上报频率,设置为0 表示不执行上报
    public uint upTransferFrequency=0;
    //上传是否需要添加推算数据
    public bool permitUpComputative;
    //

    //

    //

    //运动过程中，允许未收到下一步位置包的情况下，提前移动一段距离
    public bool permitMoveAdvance=true;
    //运动过程中,判断因延迟过大而不适合插值,允许直接跳到目标点
    public bool permitJumpToTarget=true;
    //判断瞬移距离阈值,超过此值，可能需要瞬移
    public float needJumpLimit = 100;
    //

    //
}
